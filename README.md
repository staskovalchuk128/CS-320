# CS-320
<h3>How can I ensure that my code, program, or software is functional and secure?</h3>
Ensuring the functionality and security of code can pose a significant challenge. Until now, my experience has primarily revolved around conducting tests on code within the scope of this course, which at times proved to be quite demanding. It wasn't until I undertook this class that I fully grasped the intricacies involved in this process. My strategy for guaranteeing both the functionality and security of my code hinges on adhering closely to the specified requirements and crafting comprehensive tests that yield a high coverage percentage during testing phases. In this course, I meticulously tested and refined my code until I achieved coverage percentages of at least 90%, thus ensuring its robustness. Ensuring the functionality of the code primarily entailed strict adherence to the established requirements, while guaranteeing its security involved the creation of thorough tests aligned with these requirements.

<h3>How do I interpret user needs and incorporate them into a program?</h3>
I begin the process of interpreting user needs by initially reading them and then dissecting them into components that are compatible or incompatible with a program. An illustrative instance of this approach involves considering constraints such as maximum length and handling empty submissions. For instance, when faced with specifications dictating that names must neither be null nor exceed 10 characters, I assimilated this requirement into the program by implementing an if statement that addressed both potential failure scenarios. This method represents a fundamental means of translating user needs into program logic, as it directly translates the requirement into a conditional statement for successful execution. However, some requirements are more nuanced and require deeper analysis. In a separate class project, for example, a program was needed to increment time on two distinct clocks at the push of a button. Addressing this requirement necessitated a more exhaustive breakdown of the functionality, which differed from the straightforward handling of constraints like those previously mentioned. In such cases, the overarching requirement isn't as straightforward as simply creating an illegal argument exception; rather, it demands a more intricate approach to fulfill the user's needs effectively.

<h3>How do I approach designing software?</h3>
I acknowledge that there's room for refinement in my software design approach. Typically, I start by reviewing the requirements documents or interview transcripts, if available, and compile a checklist of the specified requirements. These requirements are then, if applicable, further dissected into a list of necessary objects and methods needed for implementation. Armed with these lists, I proceed to write the code to fulfill the identified requirements. After the initial implementation, I conduct a thorough review to enhance efficiency wherever possible. While this method has proven effective in my academic pursuits thus far, I recognize the need for a more comprehensive and insightful approach. Therefore, I am open to exploring alternative methods that offer a broader perspective and deeper understanding in software design.
